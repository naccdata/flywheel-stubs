"""
This type stub file was generated by pyright.
"""

"""
    Flywheel

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 0.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""
class UploadApi:
    def __init__(self, api_client=...) -> None:
        ...
    
    def cleanup_signed_upload_url(self, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Cleanup unused file blob previously uploaded using signed URL

        This method makes a synchronous HTTP request by default.

        :param SignedUrlCleanupInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        ...
    
    def cleanup_signed_upload_url_with_http_info(self, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Cleanup unused file blob previously uploaded using signed URL

        This method makes a synchronous HTTP request by default.

        :param SignedUrlCleanupInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: None
        """
        ...
    
    def complete_s3_multipart_upload(self, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Complete S3 multipart signed url upload

        Complete S3 uploads exceeding 5GB and create the final object in the bucket. Expected an upload id returned previously by the `POST /upload/signed-url` endpoint and the e-tags returned by S3 after uploaded each file part.
        This method makes a synchronous HTTP request by default.

        :param CompleteS3MultipartUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CompleteMultipartUploadOutput
        """
        ...
    
    def complete_s3_multipart_upload_with_http_info(self, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Complete S3 multipart signed url upload

        Complete S3 uploads exceeding 5GB and create the final object in the bucket. Expected an upload id returned previously by the `POST /upload/signed-url` endpoint and the e-tags returned by S3 after uploaded each file part.
        This method makes a synchronous HTTP request by default.

        :param CompleteS3MultipartUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: CompleteMultipartUploadOutput
        """
        ...
    
    def create_signed_upload_url(self, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Create new signed upload URL

        Return a signed upload URL for the requested storage provider_id. Multiple URLs are returned for S3 uploads exceeding 5GB.
        This method makes a synchronous HTTP request by default.

        :param SignedUrlUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedUrlUploadOutput
        """
        ...
    
    def create_signed_upload_url_with_http_info(self, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Create new signed upload URL

        Return a signed upload URL for the requested storage provider_id. Multiple URLs are returned for S3 uploads exceeding 5GB.
        This method makes a synchronous HTTP request by default.

        :param SignedUrlUploadInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedUrlUploadOutput
        """
        ...
    
    def upload_by_label(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > For technical reasons, no form field names can be repeated. Instead, use   (file1, file2) and so forth.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/labelupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ...
    
    def upload_by_label_with_http_info(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > For technical reasons, no form field names can be repeated. Instead, use   (file1, file2) and so forth.  > A non-file form field called \"metadata\" is also required, which must be   a string containing JSON.  > See ``api/schemas/input/labelupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ...
    
    def upload_by_reaper(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Bottom-up UID matching of Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior:  > Upload data, allowing users to move sessions during scans without causing new data to be   created in referenced project/group.  ### Evaluation Order:  * If a matching acquisition UID is found anywhere on the system, the related files will be placed under that acquisition. * **OR** If a matching session UID is found, a new acquistion is created with the specified UID under that Session UID. * **OR** If a matching group ID and project label are found, a new session and acquisition will be created within that project * **OR** If a matching group ID is found, a new project and session and acquisition will be created within that group. * **OR** A new session and acquisition will be created within a special \"Unknown\" group and project, which is only visible to system administrators.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool uid_placement:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ...
    
    def upload_by_reaper_with_http_info(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Bottom-up UID matching of Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior:  > Upload data, allowing users to move sessions during scans without causing new data to be   created in referenced project/group.  ### Evaluation Order:  * If a matching acquisition UID is found anywhere on the system, the related files will be placed under that acquisition. * **OR** If a matching session UID is found, a new acquistion is created with the specified UID under that Session UID. * **OR** If a matching group ID and project label are found, a new session and acquisition will be created within that project * **OR** If a matching group ID is found, a new project and session and acquisition will be created within that group. * **OR** A new session and acquisition will be created within a special \"Unknown\" group and project, which is only visible to system administrators.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param bool uid_placement:
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ...
    
    def upload_by_uid(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > Same behavior as /api/upload/label,   except the metadata field must be uid format   See ``api/schemas/input/uidupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ...
    
    def upload_by_uid_with_http_info(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Multipart form upload with N file fields, each with their desired filename.

        ### Default behavior: > Same behavior as /api/upload/label,   except the metadata field must be uid format   See ``api/schemas/input/uidupload.json`` for the format of this metadata.  ### Signed URL upload with ``ticket`` > Upload a single file directly to the storage backend. The workflow is the following:    - Send a request with an empty ``?ticket=`` query parameter to get an upload ticket and URL   - Upload the file using a PUT request to the upload URL   - Once done, send a POST request to this endpoint with the upload ticket to finalize the upload.   The file will be placed into the DB via this POST request.
        This method makes a synchronous HTTP request by default.

        :param bool preserve_metadata:
        :param str ticket: Use empty value to get a ticket, and provide the ticket id to finalize the upload
        :param str id:
        :param ContainerType level:
        :param str job:
        :param str files:
        :param object metadata: Metadata object
        :param str content_type:
        :param bool async_: Perform the request asynchronously
        :return: union[list[File],UploadTicketOutput]
        """
        ...
    
    def upload_signed_fs_file(self, token, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Upload file to local filesystem storage provider

        The POST `/api/upload/signed-url` endpoint returns a url with a jwt token pointing to this endpoint if the storage provider is a local filesystem then the file can be uploaded simply by sending the file content in the body of the payload. The destination storage provider and the file path are encoded in the jwt token.
        This method makes a synchronous HTTP request by default.

        :param str token: Upload token (required)
        :param str body: Signed filesystem file upload payload (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedFSUploadOutput
        """
        ...
    
    def upload_signed_fs_file_with_http_info(self, token, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Upload file to local filesystem storage provider

        The POST `/api/upload/signed-url` endpoint returns a url with a jwt token pointing to this endpoint if the storage provider is a local filesystem then the file can be uploaded simply by sending the file content in the body of the payload. The destination storage provider and the file path are encoded in the jwt token.
        This method makes a synchronous HTTP request by default.

        :param str token: Upload token (required)
        :param str body: Signed filesystem file upload payload (required)
        :param bool async_: Perform the request asynchronously
        :return: SignedFSUploadOutput
        """
        ...
    


