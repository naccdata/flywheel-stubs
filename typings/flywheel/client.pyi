"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, List, Optional

from flywheel.finder import Finder
from flywheel.models.acquisition import Acquisition
from flywheel.models.collection import Collection

from flywheel.models.data_view import DataView
from flywheel.models.deleted_result import DeletedResult
from flywheel.models.file_entry import FileEntry
from flywheel.models.gear import Gear
from flywheel.models.gear_rule import GearRule
from flywheel.models.gear_rule_input import GearRuleInput
from flywheel.models.group import Group

from flywheel.models.job import Job
from flywheel.models.project import Project
from flywheel.models.project_settings_output import ProjectSettingsOutput
from flywheel.models.role_output import RoleOutput
from flywheel.models.session import Session
from flywheel.models.subject import Subject
from flywheel.models.user import User
from flywheel.models.view_id_output import ViewIdOutput
from flywheel.models.viewer_app import ViewerApp


def get_api_key_from_cli(path) -> str: # -> Any:
    ...

class Client:
    def __init__(self, api_key: Optional[str], **kwargs: Dict[str, Any]) -> None:
        """Initialize Flywheel Client

        Note: If you are initializing the client with a drone or device key,
        you will need to set disable_auth_check to True

        Args:
            api_key: API key to Flywheel
            kwargs: Other keyword arguments
                disable_auth_check (bool): Disable authentication check.
                    Default False.

        Returns:
            Initialized Flywheel Client

        Raises:
            flywheel.rest.ApiException: If disable_auth_check is False and
                authentication fails.
        """
        ...

    def shutdown(self) -> None:
        """Release any outstanding resources"""
        ...

    def add_user(self, user: User) -> str:
        """Add a new user"""
        ...

    def add_group(self, group: Group) -> str:
        """Add a new group"""
        ...

    def add_collection(self, *args, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Create a collection"""
        ...

    def add_gear(self, gear_name, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Create or update a gear.

        If no existing gear is found, one will be created Otherwise, the specified gear will be updated

        :param str gear_name: Name of the gear to interact with (required)
        :param GearDocumentLegacyInput body: (required)
        :param bool async_: Perform the request asynchronously
        :return: GearDocument
        """
        ...

    def add_job(self, body, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Add a job

        :param Job body: (required)
        :return: CommonObjectCreated
        """
        ...

    def get_config(self, **kwargs) -> Dict[str, Any]:
        """Return public Scitran configuration information

        :return: ConfigOut
        """
        ...

    def get_gear(self, gear_id, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Return a gear referenced by gear_id

        :param str gear_id: (required) The id of the gear to lookup
        :return: Gear
        """
        ...

    def get_version(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Get server and database schema version info

        :return: VersionOutput
        """
        ...

    def get_current_user(self, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Get current logged-in user

        :return: User
        """
        ...

    def get_modality(self, modality_id, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Get a modality's classification specification

        :param str modality_id: (required)
        :return: Modality
        """
        ...

    def get(self, id, **kwargs): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Retrieve the specified object by id.

        Objects that can be retrieved in this way are:
            group, project, session, subject, acquisition, analysis and collection

        :param str id: The id of the object to retrieve
        :return: ContainerOutput
        """
        ...

    def resolve(self, path: str) -> Any:
        """Perform a path based lookup of nodes in the Flywheel hierarchy.

        :param str path: The path to lookup
        :return: ResolverOutput
        """
        ...

    def lookup(self, path: str) -> Any:
        """Perform a path based lookup of a single node in the Flywheel hierarchy.

        :param str path: The path to lookup
        :return: ResolverOutput
        """
        ...

    def file_url(self, path):
        """Perform a path based lookup of a file in the Flywheel hierarchy, and return a single-use download URL.

        :param str path: (required) The path to resolve
        :return: The file URL if found, otherwise raises an error
        """
        ...

    def download_tar(self, containers, dest_file, include_types=..., exclude_types=...): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Download the given set of containers as a tarball to dest_file.

        Supports downloading Projects, Sessions, Acquisitions and/or Analyses.

        :param containers: (required) The container, or list of containers to download.
        :param str dest_file: (required) The destination file on disk
        :param list include_types: The optional list of types to include in the download (e.g. ['nifti'])
        :param list exclude_types: The optional list of types to exclude from the download (e.g. ['dicom'])
        :return: A summary of the download
        """
        ...

    def download_zip(self, containers, dest_file, include_types=..., exclude_types=...): # -> str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Enum | _Date | datetime | RESTResponse | Response | tuple[str | list[list[Any] | dict[Any, list[Any] | dict[Any, Any] | Any | str | Enum | _Date | datetime | None] | Any | str | Enum | _Date | datetime | None] | dict[Any, Any] | Any | Enum | _Date | datetime | RESTResponse | Response | None, Any, Any] | AsyncResult | None:
        """Download the given set of containers as a zip archive to dest_file.

        Supports downloading Projects, Sessions, Acquisitions and/or Analyses.

        :param containers: (required) The container, or list of containers to download.
        :param str dest_file: (required) The destination file on disk
        :param list include_types: The optional list of types to include in the download (e.g. ['nifti'])
        :param list exclude_types: The optional list of types to exclude from the download (e.g. ['dicom'])
        :return: A summary of the download
        """
        ...

    @property
    def users(self) -> Finder[User]: # -> Finder:
        """Returns the users finder object"""
        ...

    @property
    def groups(self) -> Finder[Group]:
        """Returns the groups finder object"""
        ...

    @property
    def projects(self) -> Finder[Project]:
        """Returns the projects finder object"""
        ...

    @property
    def subjects(self) -> Finder[Subject]: # -> Finder:
        """Returns the subjects finder object"""
        ...

    @property
    def sessions(self) -> Finder[Session]: # -> Finder:
        """Returns the sessions finder object"""
        ...

    @property
    def acquisitions(self) -> Finder[Acquisition]: # -> Finder:
        """Returns the acquisitions finder object"""
        ...

    @property
    def jobs(self) -> Finder[Job]:
        """Returns the jobs finder object"""
        ...

    @property
    def gears(self) -> Finder[Gear]: # -> Finder:
        """Returns the gears finder object"""
        ...

    @property
    def collections(self) -> Finder[Collection]: # -> Finder:
        """Returns the collections finder object"""
        ...

    @property
    def data_view_executions(self): # -> Finder:
        """Returns the data_view_executions finder object"""
        ...

    def View(self, **kwargs) -> DataView: # -> DataView:
        """Short-hand for ``flywheel.ViewBuilder(**kwargs).build()``

        :param kwargs: The arguments to pass directly to ViewBuilder
        :return: The built data view
        """
        ...

    def print_view_columns(self, file=...): # -> None:
        """Print a list of column aliases that can be used in data views.

        :param file-like file: The file to print to
        """
        ...

    def read_view_data(self, view, container_id, decode=..., **kwargs): # -> StreamReader | HTTPResponse | Any:
        """Execute a data view against container, and return a file-like object that can be streamed.

        :param view: The view id or DataView object to execute.
        :type view: str or DataView
        :param str container_id: The id of the container to execute the view against
        :param bool decode: Whether or not to decode the stream to utf-8 (default is true)
        :param kwargs: Additional arguments to pass to the evaluate_view call. (e.g. format='csv')
        :return: A file-like object where the contents can be read
        """
        ...

    def read_view_dataframe(self, view, container_id, opts=..., **kwargs) -> Any:
        """Execute a data view against container, and return a DataFrame.

        NOTE: This requires that the pandas module be installed on the system.

        :param view: The view id or DataView object to execute.
        :type view: str or DataView
        :param str container_id: The id of the container to execute the view against
        :param object opts: Additional options to pass to the pandas read_json function
        :param kwargs: Additional arguments to pass to the evaluate_view call.
        :return: A pandas DataFrame
        """
        ...

    def save_view_data(self, view, container_id, dest_file, **kwargs): # -> None:
        """Execute a data view against container, and save the results to disk.

        :param view: The view id or DataView object to execute.
        :type view: str or DataView
        :param str container_id: The id of the container to execute the view against
        :param str dest_file: The destination file path
        :param kwargs: Additional arguments to pass to the evaluate_view call. (e.g. format='csv')
        """
        ...

    # Additional methods from hand-curated version
    def get_file(self, file_id: str) -> FileEntry:
        """Get file by ID"""
        ...

    def get_group(self, id: str) -> Group:
        """Get group by ID"""
        ...

    def get_all_roles(self) -> List[RoleOutput]:
        """Get all available roles"""
        ...

    def add_role_to_group(self, group_id: str, body: Any) -> None:
        """Add role to group"""
        ...

    def get_project_rules(self, project_id: str) -> List[GearRule]:
        """Get project rules"""
        ...

    def add_project_rule(self, project_id: str, body: GearRuleInput) -> GearRule:
        """Add project rule"""
        ...

    def remove_project_rule(self, project_id: str, rule_id: str) -> None:
        """Remove project rule"""
        ...

    def modify_user(self, user_id: str, body: Dict[str, str]) -> None:
        """Modify user"""
        ...

    def get_views(self, view_id: str) -> List[DataView]:
        """Get views"""
        ...

    def add_view(self, container_id: str, body: Any) -> ViewIdOutput:
        """Add view"""
        ...

    def modify_view(self, view_id: str, body: DataView) -> None:
        """Modify view"""
        ...

    def delete_view(self, view_id: str) -> DeletedResult:
        """Delete view"""
        ...

    def get_project_settings(self, project_id: str) -> ProjectSettingsOutput:
        """Get project settings"""
        ...

    def modify_project_settings(self, project_id: str, body: Dict[str, List[ViewerApp]]) -> Any:
        """Modify project settings"""
        ...

    def get_session(self, session_id: str) -> Session:
        """Get session by ID"""
        ...

    def get_subject(self, subject_id: str) -> Subject:
        """Get subject by ID"""
        ...

    def get_project(self, id: str) -> Project:
        """Get project by ID"""
        ...

    def get_acquisition(self, id: str) -> Acquisition:
        """Get acquisition by ID"""
        ...

    def get_job(self, job_id: str, **kwargs) -> Any:
        """Get job by ID"""
        ...

    def retry_job(self, job_id: str, **kwargs) -> Any:
        """Retry job"""
        ...

    def __getattr__(self, name: str) -> Any:
        ...
